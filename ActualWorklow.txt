This is essentially a REFACTORING Excercise.

High Level Worfklow:
====================
1. We need to apply a suite of Tests to the initial code, to give some coverage, and see where things will break before we refactor.
2. Once we have tests we can refactor, taking into account code smells, and SOLID principles.
3. We need to apply Triangulation when refactoring, creating new code (RED-GREEN-REFACTOR)
4. Test should use AAA framework (Arrange-Act-Assert)
5. Code checkins to have comments to show work flow, and highlight refactorings and code smells.
6. Follow "boyscout" principle.

I have decided to use BDD and TDD testing, using:
-SpecFlow (BDD)
-NUnit and RhinoMocks - (TDD)

Tests for gaining code coverage, will follow a Horizontal Slice, i.e. BDD => TDD for each test.
1.
First set of tests are unit and are really there to test the NUnit Framework and Test Runners etc, but more importantly they
make us aware that the access modifiers placed on the Program class (by default), do not allow the code to be tested from a different
test project
2.
The unit tests from above need splitting out as test scenarios should be in seperate files, so we will split to some simple Program tests
and then split and reuse one test method for testing the quality reduces each day.
As I can see that their will be some common setup, I will introduce a new abstract test class to give me an AAA framework, to
work within. The abstract class can be reused for different types of test. It can also be reused for the BDD testing.
I want an AAA (ArrangeActAssert) framework.
3.
Now we have access to the Program for testing, we can begin to introduce the Behavioural Tests.
These test are in a Given,That,Then syntax, and are SpecFlow Feature tests. They are Acceptance Tests and are great for giving test
coverage at a higher level. They cover the functionality of the application. So we will begin implementing each test, one at a time,
and adding unit tests after each scenario, in a horizontal slice.
Steps are used to build up the background code.
The scenarios are in the Acceptance Test project in a feature file (UpdateStockItems.feature), and are in the Features folder.
4. 
Having created the equuivalent unit test for Quality Reduces Each Day, which passes. It is becoming clear, that we can reuse, the 
same abstract test class WhenTestingTheGildedRoseProgram, between both Acceptance and Unit Tests.
There is would also be some use in being able to build new stock items in a common way.
Hence we will create a common testing project, and create use a creational pattern (Builder), to help creating test stock items.
5.
Following all of the above tests being completed, we can now begin refactoring.
Despite not being able to change the Item class due to the nasty goblin, we will still move the class out of the Console project into
a new project named Domain.  This Seperation of Concerns and Single Responsibility Principle.
We are not changing the Item signature.
We can test the refactor with confidence now.
6.
Refactors to Program - Update Quality for ()
1. Convert for loop to for each (var item in Items)
2. Legendary items - remove conditionals, they don't increase/decrease in value so remove them, and use an if statement, at beginning
of loop to jump to next iteration if (item=="Sulfuras.."")
3. Invert if statement for "Aged Brie" and "Backstage Passes"
4. Move "Back stage passes" out of previous if statement, and create a new else if, copy if (item quality < 50) statement into new condition from above
5. Reduce space used (readability) - Change =+1 to ++ and =-1 to -- 
6. Collapse if statements to 1 line by removing unnecessary "{" "}" 
7. Move Sell by date decreases each day calculation up to below condition for ignoring Legendary items
8. Change conditions of Backstage passes to be 10 and 5 from 11 and 6
9. Invert if statement on items where Sell by dates have passed
10. Move the backstage passes logic for they have no value when the sell by date is < 0.  Can be moved up into the Backstage passes conditional logic. 
	Rational - It condenses the code and centralises the logic together.
11. Move logic for Quality reduces each day if Sellin date is reached up to else statement in the above
	 nested ifs (this will be rules applied for anything other than "Aged Brie", "Sulfras" and "Backstage passes", i.e. Standard items)
12. Remove all the remaining logic left for is Sellin < 0, as "Aged Brie" already increases Quality Each day 
13. Move the calculation for Sellin reduces each day into each of the if statements, to get a full set of calculations 
	for each item 

Essentially, the above refactors have clean up the conditional if statements and centralised the rules to apply to 
	each set of items.
	We now have rules for:
	-"Aged Brie"
	-"Sulfuras" -Legendary items
	-"Backstage passes"
	-everything else - "Standard" items

Now we are able to extract the logic for each item into seperate methods.

15. Refactor - Extract to Method - Aged Brie Logic
16. Refactor - Extract to Method - Backstage passes Logic 
17. Refactor - Extract to Method - Standard Items Logic 
